# 11.27.(월). 13week2

<aside>
💡 주기억장치 관리

</aside>

- 1개의 프로그램 적제
1개의 프로세스
- 1개의 프로그램 적재
2개 이상 프로세스
- 연속 할당 2개 이상 프로그램 적재
- 프로그램 페이징
- 

<aside>
💡 연속 할당 2개 이상 프로그램 적제

</aside>

1. MFT ( multi programming with a Fixed of Tasks ) 정적 할당

파티션 크기에 맞게 적재함

단점 

1. 적응 X
2. 단편화 현상 발생

![Untitled](11%2027%20(%E1%84%8B%E1%85%AF%E1%86%AF)%2013week2%20c20173ca0e5648229c6b4457b0b59b9e/Untitled.jpeg)

1. MVT ( multi programming with a varitus  of Tasks) 동적 할당
    
    프로그램을 들어오는 대로 적재를 한다
    
    1. best - fit : hole 탐색시간이 가장 작은 hole 생성
    2. first - fit
    3. worst - fit
    
    문제점
    
    1. 너무 작은 홀이 만들어 질 수 있다.
    2. 외부 단편화 문제
    
    프로그램 크기 = (400kb짜리에  - 4byte) 를 적제한다.
    396kb홀이 생긴다.
    
    해결 방법
    
    1. 최소 할당 크기를 정한다.
        
        (256byte, 512byte, 1kb) 등등
        
        → 마찬가지로 내부 단편화가 발생한다.
        
    2. 큰 파일의 경우 파일을 압축을한다.(GC 가비지 콜랙션)
        
        → address binding time이 실행할 때 수행되는 프로그램만 가능
        
    

![Untitled](11%2027%20(%E1%84%8B%E1%85%AF%E1%86%AF)%2013week2%20c20173ca0e5648229c6b4457b0b59b9e/Untitled%201.jpeg)

<aside>
💡 4. 프로그램 페이징

</aside>

프로그램을 일정 페이지 단위로 나눈다.

페이지 단위로 주기억장치에 적재한다.

- 페이지 단위로 적재하니까 외부 단편화가 없다.
- 그러나 내부 단편화는 발생할 수 있다.

단점 :

- 탐색을 할때 항상 페이지 테이블을 탐색한다
- 유효 메모리 접근 시간이 줄어든다.
    - 해결책 → 페이지테이블을 메모리에 넣지 않고 캐쉬에 적재한다.

![Untitled](11%2027%20(%E1%84%8B%E1%85%AF%E1%86%AF)%2013week2%20c20173ca0e5648229c6b4457b0b59b9e/Untitled%202.jpeg)

EX)  

![Untitled](11%2027%20(%E1%84%8B%E1%85%AF%E1%86%AF)%2013week2%20c20173ca0e5648229c6b4457b0b59b9e/Untitled%203.jpeg)

Address field = 6자리

페이지 크기 = 500byte

논리 주소 → 물리 주소
002530  →  물리 주소

2530 / 500 = 몫은 5  나머지 30

페이지 주소 5

디스플레이 주소 30

페이지를 탐색 방법

- 페이지 단위로 프로그램을 적재하고 해당 프로그램 주소값을 페이지 테이블에 저장한다
- 탐색 시 페이지 테이블만 확인한다.
- 페이지 테이블만 확인하면 쉽게 탐색 가능함

![Untitled](11%2027%20(%E1%84%8B%E1%85%AF%E1%86%AF)%2013week2%20c20173ca0e5648229c6b4457b0b59b9e/Untitled%204.jpeg)

EX)  

page 크기 = 1000byte

p1 논리주소

[0][0][3][7][5][0] 

물리 주소는 찾는 법은?

3750 /  1000 =  
몫은 3  나머지 750

페이지번호 = 3

디스플레이 주소 750

페이지 번호 3을 참고하면
p1의 3는  D = 9를 가지기에 

[9][7][5][0] 주소를 가짐

EX)
P2 : 논리 주소
 [002612] 

2612 / 1000  = 몫 2 나머지 612

페이지 주소 = 2

디스플레이 주소 = 612

[002][612]

p2의 2는 g = 8을 가지기에

[008][612] 를 가진다.

주소 테이블 아레 사진 참고

![Untitled](11%2027%20(%E1%84%8B%E1%85%AF%E1%86%AF)%2013week2%20c20173ca0e5648229c6b4457b0b59b9e/Untitled%205.jpeg)

EX) 2진수로 표현

P1 논리주소

[00000000][00000110][01011111]
페이지 크기 = 512byte

몫 1001

나머지 01011111

[00000000][00001001]   [01011111]

물리주소 [00000000][00001001]

디스플레이 주소  [01011111]

EX) 페이지 테이블은 고정크기

페이지 테이블 엔트리 크키 = 8byte

address field - 24bit

페이지 크기 2^10

페이지 테이블 크기는?

[         p       ][     d    ]

p = 14

d = 10

p + d = 24bit

cash = TMB 같은 말이다.

캐쉬 

ex)  시험 문제

memory = access time = 120nsec

cash asccess time = 20nsec

hit ratio = 90 %

effective memory time은 얼마인가?

0.9 *  20  +0.1(20 + 120) = 32nsec

EX)

캐쉬 access = 10nesc

주기억장치 Access time = 100nesc

hit ratio = 80%

effective memory time은 얼마인가?

0.8*(10 +100) + 0.2*(100 + 100 + 100)

= 130nsec