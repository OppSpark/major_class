## 과제
https://github.com/OppSpark/2023_2_problem/blob/main/6week/greedy1017_%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%E1%84%89%E1%85%B5%E1%86%AF%E1%84%87%E1%85%A2%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6.ipynb

## 자료
https://github.com/OppSpark/2023_2_problem/blob/main/6week/Greedy6%E1%84%8C%E1%85%AE8%E1%84%8C%E1%85%AE.ipynb


<aside>
💡 퀵소트에서 피벗을 선택하는 방법

</aside>

퀵소트 시 피벗이 한쪽으로 치우친 경우 해결 방법은?

- 투키의 방법 : 피벗을 3가지 뽑아서 중간값을 사용한다.

퀵소트의 수행 시간

최선의 경우 : O(nLogn)

평균의 경우 : O(nLogn)

최악의 경우 : O(n^2)

대부분 O(nLogN) 에 풀린다.

<aside>
💡 합병 정렬

</aside>

합병 정렬 (머지 소트) : 크기가 n 을 입력 받아 정확히 반으로 나누고 나누어진 값을 다시 반으로 분할 후 값이 1개가 남았을 때 합병하여 정렬 한다.

합병 정렬

- 현재 입력 크기가 1이면 return
- 현재 입력을 반으로 나눈다.
- 앞부분을 동일한 방법으로 정렬한다.
- 뒷부분을 동일한 방법으로 정렬한다.
- 정렬된 앞부분과 뒷부분을 합병한다.

[단점] : 합병을 위해 입력 크기의 보조메모리가 필요하다

수행시간

O(nlogn)

모든 수행 시간이 동일하다.

책 p.105

<aside>
💡 K 번째 작은 수

</aside>

가장 작은 수 찾아 지우기

ex) 4번째 작은 수 지우기

1. 최소 힙을 사용해 k번 루트 삭제
    - 이진 힙을 사용하면 O(N) 시간에 삭제 가능
    
2. 반으로 나누기
    - 피벗을 사용해 값을 정하고 피벗을 기준으로 큰 수 작은 수로 분할함
    

K번째 작은 수 찾기

1. 피벗을 랜덤하게 선택한다
2. 피벗과 각 숫자를 비교하여 피벗보다 작은 수를 왼쪽, 큰 수를 오른쪽
3. K번째 작은 숫자가 피벗이면 True
4. 아니라면 계속 탐색

수행 시간 O(n)

<aside>
💡 가장 가까운 두 점

</aside>

반으로 나누어 해결하기

책 p.112

최근접 쌍 알고리즘

1. 점의 수가 2~3개 만 있으면 승자를 반환
2. 왼쪽 1/2 부분에서 최근접 쌍을 찾는다
3. 오른쪽 1/2 부분에서 최근접 쌍을 찾는다
4. 비무장 지대에서도 최근접 쌍을 찾는다
5. 2 ~ 4에서 찾은 최근접 쌍 중에서 승자를 찾는다.

분할 정복( 최근접 쌍) 을 이용하면 시간 복잡도는

O(n log^2 n)

라인스위핑 알고리즘을 이용하면
O(nlogN)
