# 9.20.(수) 3week1

![스크린샷 2023-09-20 오후 2.06.27.png](9%2020%20(%E1%84%89%E1%85%AE)%203week1%20c1bdd9918ea546ca9d1b301ea0a84d99/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-09-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.06.27.png)

익스텐트 = 클러스터의 크기가 가변으로 구성

FAT 의 구조

- 클러스터 방식의 FAT와 달리 각 익스텐트의 크기 정보가 필요함

![스크린샷 2023-09-20 오후 2.05.06.png](9%2020%20(%E1%84%89%E1%85%AE)%203week1%20c1bdd9918ea546ca9d1b301ea0a84d99/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-09-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.05.06.png)

512 바이트 섹터에 300바이트를 저장하는 방법

spanning 방식  //중요

- 2개의 섹터에 걸쳐서 저장함

Non - spanning 방식   //중요

- 각 섹터당 하나의 데이터만 저장 - 접근 시간 보장
- ex) 512 크기의 섹터에 300 데이터 2개를 저장하면
    - - 각 섹터당 212바이트의 공간이 낭비됨

내부 단편화, 외부 단편화

![스크린샷 2023-09-20 오후 2.19.51.png](9%2020%20(%E1%84%89%E1%85%AE)%203week1%20c1bdd9918ea546ca9d1b301ea0a84d99/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-09-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.19.51.png)

트랙의 구성 방식

- 섹터 방식 : 고정 크기의 저장 단위
- 블록 방식 : 사용자 정의 크기의 저장 단위

블록 방식

저장할 레코드 수에 맞게 크기 지정

- 블록킹 계수(blocking factor) : 파일내 각 블록에 저장할 고정적 레코드 수

섹터 구성 방식

![스크린샷 2023-09-20 오후 2.23.13.png](9%2020%20(%E1%84%89%E1%85%AE)%203week1%20c1bdd9918ea546ca9d1b301ea0a84d99/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-09-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.23.13.png)

Ex) 1번 레코드를 읽으려면 섹터 1~3을 읽어야한다.

블록 구성 방식

![스크린샷 2023-09-20 오후 2.23.27.png](9%2020%20(%E1%84%89%E1%85%AE)%203week1%20c1bdd9918ea546ca9d1b301ea0a84d99/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-09-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.23.27.png)

하드웨어 단에서 블록의 크기를 자동으로 정해줌

![스크린샷 2023-09-20 오후 2.28.04.png](9%2020%20(%E1%84%89%E1%85%AE)%203week1%20c1bdd9918ea546ca9d1b301ea0a84d99/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-09-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.28.04.png)

블록 주소 방식

다시 정리할 것!

다시 정리할 것!

다시 정리할 것!

![스크린샷 2023-09-20 오후 2.30.07.png](9%2020%20(%E1%84%89%E1%85%AE)%203week1%20c1bdd9918ea546ca9d1b301ea0a84d99/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-09-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.30.07.png)

<aside>
💡 Non-data Overhead

</aside>

EX) 512gb HDD를 구입 했는데 막상 사용하면 460gb 이다. 이유는?

- 섹터와 섹터 사이 간격이 있을 수 있음
- 섹터와 트랙을 그리는 간격 때문
- 포멧 시 필수 정보 (FAT, 파일마다 부수적으로 필요한 data)
- 파일 시스템 운영에 필요한 정보 등

![스크린샷 2023-09-20 오후 2.49.16.png](9%2020%20(%E1%84%89%E1%85%AE)%203week1%20c1bdd9918ea546ca9d1b301ea0a84d99/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-09-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.49.16.png)

Non-data Overhead

영역

섹터 주소 방식

- 섹터 주소, 트랙 주소, 각 섹터 시작점 등과 같은 정보
- 섹터 사이의 간격(GAP)과 동기화 표시
- 프로그래머의 결정 사항 아님

블록 구성 방식

- 서브블록이나 데이터 블록 사이의 간격
- 블록의 개수나 크기는 가변

![스크린샷 2023-09-20 오후 2.51.29.png](9%2020%20(%E1%84%89%E1%85%AE)%203week1%20c1bdd9918ea546ca9d1b301ea0a84d99/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-09-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.51.29.png)

블록킹 계수의 효과

위 PPT 참고

blocking factor = 10 인 경우

- 각 데이터 블록의 크기 : 1,300(=1,000+300) 바이트
- 한 트랙에 15개 데이터 블록 저장 (20,000/1,300= 15.38) : 15*1,000
= 15,000 바이트의 순수 데이터를 저장

blocking factor = 60 인경우

- 각 데이터 블록의 크기 : 6,300(=6,000+300) 바이트
- 한 트랙에 3개 데이터 블록 저장 (20,000/6,300=3.17) : 3*6,000
    
     =  18,000 바이트의 순수 데이터를 저장
    

![스크린샷 2023-09-20 오후 2.56.46.png](9%2020%20(%E1%84%89%E1%85%AE)%203week1%20c1bdd9918ea546ca9d1b301ea0a84d99/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-09-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.56.46.png)

<aside>
💡 디스크 접근 시간

</aside>

Seek = 헤드의 좌우 이동

Seek time = 헤드가 실린더 위치까지 이동하는 시간

회전 지연 시간

seek 가 원하는 실린더까지 도착 후 

- 지정된 섹터가 헤드 밑에 까지 오는 시간

5.000rpm  일 경우  :   60/5,000  (60초에 5000번 돌아감)

- 1바퀴에 12msec/rotation
- 평균 회전 지연 시간 : 6msec      // 평균 회전 지연 시간 = 1바퀴 도는 시간 / 2 ;

ex) 플로피 디스크의 경우

360rpm : 1회전에 83.3msec 소요

![스크린샷 2023-09-20 오후 3.24.05.png](9%2020%20(%E1%84%89%E1%85%AE)%203week1%20c1bdd9918ea546ca9d1b301ea0a84d99/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-09-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.24.05.png)

전송 시간(transfer time)

디스크 1회전 시간과 동일함

전송시간 = ( 전송될 바이트 크기 / 트랙당 바이트 크기 ) * 1회전 시간

디스크가 10,000 rpm의 회전수를 가질 때 하나의 섹터를 전송하는 시간 

: 트랙당 170개 섹터인 경우 0.036 msec (6 msec/170 sectors) : 14 MBytes/sec

속도를 늘리려면 트랙당 섹터를 늘리면 된다.

![스크린샷 2023-09-20 오후 3.40.32.png](9%2020%20(%E1%84%89%E1%85%AE)%203week1%20c1bdd9918ea546ca9d1b301ea0a84d99/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-09-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.40.32.png)

**8,704,000 바이트 크기의
파일 저장**

34,000개의 256-byte 레코드

4096의 클러스터를 가짐 →  클러스터당 16개의 256바이트를 저장함

- 파일은 34,000 / 16 = 2.125개의 물리적으로 연속된 클러스터가 필요함

Cheetah 디스크에서 파일 저장에 필요한 트랙 수

- 클러스터당 4,096 / 512 - 8개의 섹터가 필요함
- 트랙당 섹터의 수 = 170 (170 * 512 = 87,040 bytes) // 트랙 사이즈
    - 트랙에 170 / 8 = 21.25개의 클러스터 저장
- 파일은 2125 / 21.25         =      100개의 트랙이 필요함

스팬이 방식은  트랙당 21.25개의 클러스터를 사용할 수 있음

논 스패닝 방식의 경우 트랙당 21개의 클러스터를 사용할 수 있음

![Untitled](9%2020%20(%E1%84%89%E1%85%AE)%203week1%20c1bdd9918ea546ca9d1b301ea0a84d99/Untitled.jpeg)