# 10.11.(수) 6week1

![스크린샷 2023-10-11 14.14.53.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_14.14.53.png)

6 ~ 9 번 디스크 I/O

![스크린샷 2023-10-11 14.06.47.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_14.06.47.png)

![스크린샷 2023-10-11 14.07.00.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_14.07.00.png)

파일 포인터가 +1 이 되도록 함

write

- write는 디스크에 있는 데이터를 램에 적제 후 write 값을 기록함
    - RAM 상에 write 를 하지 disk 에 직접 write 하지는 않음

![스크린샷 2023-10-11 14.16.15.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_14.16.15.png)

I/O 프로그램

- IOP가 실행하는 명렁어의 집합
- FM은 IOP에게 I/O 작업에 대한 정보를 전송
    - 디스크 드라이브 ID, 처리할 데이터의 위치 및 크기 등의 정보

![스크린샷 2023-10-11 14.15.27.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_14.15.27.png)

DISK 에 값을

I/O 프로세서 의 역할

잘 기억 해야함

<aside>
💡 버퍼 관리

</aside>

![스크린샷 2023-10-11 14.19.40.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_14.19.40.png)

![스크린샷 2023-10-11 14.20.09.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_14.20.09.png)

in.txt 파일을 한 문자씩 읽어서 out.txt파일에 넣고 저장하는 것

![스크린샷 2023-10-11 14.21.10.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_14.21.10.png)

파일을 한문자 씩 읽고 클러스터 단위로

파일을 4k 단위로 잘라서 클러스터로 저장됨

디스크 상의 주소는 FAT에 저장됨

0번 (클러스터) 안에 있는 문자를 전부 읽고  1번(클러스터) 문자를 읽을 때 탐색함

순서

0번(클러스터)를 디스크가 읽음

클러스터를 읽고 I/O P 가 램에 데이터를 적재함

문자 하나를 읽어서 ch에 적재함

0번 클러스터를 다 읽었다면

1번(클러스터)를 읽음
클러스터를 읽고 I/O P 가 램에 데이터를 적재함

문자 하나를 읽어서 ch에 적재

계속 반복 후 다 전부 읽었다면

out.txt 파일에 저장 해야함

만약 out.txt 파일이 있다면 첫 문자 부터 덮어쓰기

out.txt 파일이 없다면

I/O P가 disk 0번(클러스터)를 확보

파일을 집어 넣음

1번(클러스터)를 확보 

파일을 집어 넣음

— 5번 이므로 5번 반복함

ex) 409600 개의 바이트가 있다면?

4096000 / 4096번 어쩌구 저쩌구

응용해서

![Untitled](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/Untitled.jpeg)

![스크린샷 2023-10-11 14.35.16.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_14.35.16.png)

입력 파일을 I/O P가 읽어와 입력용 버퍼에 넣음

만약 입/출력 버퍼가 하나 밖에 없다면 문자 하나를 읽고 쓸 때 디스크 I/O 가 3번 사용됨

입력용 버퍼, 출력용 버퍼가 각 각 있다면 문자 하나를 읽고 쓸 때 디스크 I/O 가 2번 사용됨

<aside>
💡 이중 버퍼링(Double Buffering)

</aside>

![스크린샷 2023-10-11 14.42.04.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_14.42.04.png)

이중 버퍼링 I/O 작업과 CPU 작업을 동시에 진행 할 수 있도록 하는것

buffer 1은 받은 값을 디스크 I/O에 넣는것

buffer 2는 프로그램으로 부터 받은 데이터를 저장 하는 것

buffer 1, buffer 2 속도가 같다면 ㄱㅊ음

buffer 1이 buffer 2 보다 속도가 빠르다면

- buffer 2를 더 추가하면 속도가 맞아짐

<aside>
💡 버퍼 풀링

</aside>

![스크린샷 2023-10-11 14.46.50.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_14.46.50.png)

버퍼에 디스크 정보를 저장하는데 

버퍼가 가득 찼을 때  해결하는 방법

버퍼에서 하나를 버리면 된다.

버퍼 대체 전략 (buffer replacement strategy)

- LRU (least recently used)
    - 가장 최근까지도 사용된 적이 없는 버퍼를 선택
- MRU (most recently used)
    - 가장 최근에 사용된 버퍼 선택
    

<aside>
💡 버퍼 풀링

</aside>

![스크린샷 2023-10-11 14.55.53.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_14.55.53.png)

데이터 방식

버퍼에 있는 데이터를 읽을 때 어쩔 수 없이 시스템 영역에 저장해야한다.

이걸 프로텍션 하는 방법

이동 방식 (move mode)

시스템에 있는 데이터를 유저 영역에 복제 후 작업

메모리 카피 시간 걸림, 안전

참조 방식
시스템 주소 영역을 직접 참조 해 쓰는것

빠름, 보안 낮음

<aside>
💡 UNIX 커널의 I/O 구조

</aside>

![스크린샷 2023-10-11 15.11.19.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_15.11.19.png)

I/O 시스템

Block I/O system (normal files)  // Block I/O system (normal files) 파일과 관련된 시스템

Character I/O system (terminals, printers, etc.) // 문자 단위로 ,터미널, 마우스, 프린터

Network I/O system (sockets)  // 네트워크 관련 I/O 를 위한시스템

![스크린샷 2023-10-11 15.16.21.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_15.16.21.png)

프로세스마다 파일 식별자 테이블을 가진다.

- 파일을 오픈 할때 마다

시스템에 한 개의 open 파일 테이블 존재

- 파일이 open 또는 생성될 때마다 새로운 항목을 file structure 이 파일 테이블에 추가됨
- 각항목은파일에대한다음정보를포함:
l 읽기 또는 기록 모드, 현재 이 항목을 사용하는 프로세스의 수, 다음
- 읽기 또는 기록할 파일 내의 바이트 위치
l 파일을처리하기위해사용될함수에대한포인터배열

![스크린샷 2023-10-11 15.18.58.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_15.18.58.png)

인덱스 노드( Inode)

파일에 대한 다음 정보를 포함하는 영구적인 구조

- FAT 정보 (파일이 디스크 상에 저장된 위치)
- 파일의 크기, 소유자, 접근 시간 등등

file structure는 파일이 open 되는 동안만 존재

- i node는 파일이 디스크에 존재하는 한은 디스크 파일과 함께 저장됨

![스크린샷 2023-10-11 15.21.44.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_15.21.44.png)

![스크린샷 2023-10-11 15.23.58.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_15.23.58.png)

offset of next access → 파일에 대한 정보

ptr to write routine → 파일 여는 정보

to ***inode*** table → 위치 정보 등등 가짐

책 참고 책참고 책참고!!

<aside>
💡 Inode 구조

</aside>

![스크린샷 2023-10-11 15.34.09.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_15.34.09.png)

![스크린샷 2023-10-11 15.34.42.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_15.34.42.png)

12번의 경우 젤 끝에 있는 파일을 읽을면 disk I/O를 4번 읽어야함

![스크린샷 2023-10-11 15.37.51.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_15.37.51.png)

디렉토리

- 각 파일의 이름과 디스크상의 inode 주소의 쌍을 연결하는 작을 “파일”

링크

하드링크

- I node의 주소를 하드링크라고 함
- inode를 아무도 사용하지 않으면 디스크에서 완전히 삭제함

소프트링크 

- 소스파일에 대한 경로면
- EX) 윈도우즈의 바로가기 기능

![스크린샷 2023-10-11 15.41.30.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_15.41.30.png)

소프트링크

Ex) ln –s /csd/tmp/main.cc  index.cc

- [index.cc](http://index.cc) 를 실행하면      → /csd/tmp/main.cc 가 실행됨

![스크린샷 2023-10-11 15.48.50.png](10%2011%20(%E1%84%89%E1%85%AE)%206week1%20ee024f4152b646d2b4868b42256936a5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-11_15.48.50.png)