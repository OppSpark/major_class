# 11.01.(수) 9week1

버퍼 머시기 클래스

![스크린샷 2023-11-01 14.06.32.png](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-11-01_14.06.32.png)

레코드 수준에서

가변길이 레코드를 선택하면

- 필드도 가변으로 선택된다.

고정 길이 레코드를 선택하면

- 필드도 고정 길이가 된다.

![스크린샷 2023-11-01 14.08.34.png](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-11-01_14.08.34.png)

이게 뭔 개소리인지?

![스크린샷 2023-11-01 14.12.29.png](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-11-01_14.12.29.png)

`ifstream stream을 in.txt파일을 읽기 모드로 열었다.`

`DelimFieldBuffer Buffer 방식으로 열겠다. (가변길이 방식)으로`

`Buffer.Read(stream); 읽는 과정 
 MaryAmes.Unpack(Buffer); 언팩 하는 과정`

읽는 클래스Pack ,  쓰는 클래스UnPack 클래스 2개 가 필요함

이걸 해결하기 위해서 하나로 합친것이 아래 ppt

![스크린샷 2023-11-01 14.15.47.png](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-11-01_14.15.47.png)

```cpp
class BufferFile
{
public:
	BufferFile (IOBuffer &); // create with a buffer
	int Open (char *filename, int MODE); // open an existing file
	int Create (char *filename, int MODE); // create a new file
	int Close ();
	int Rewind (); // reset to the first data record
	int Read (int recaddr = -1);
	int Write (int recaddr = -1); // write the current buffer contents 
	int Append (); // write the current buffer at the end of file
protected:
   IOBuffer & Buffer; 
   fstream File;
};

DelimFieldBuffer buffer;  // 뭐하는건지 검색
BufferFile file (buffer); // 버퍼 객체를 뭐하는건지 검색 중요함
// buffer는 레코드구조를 나타낸다.  /중요함/

file.Open(myfile);  // 내가 읽을 데이터 파일 오픈
file.Read();        // 읽기 -> 여기서 읽은 내용을  "BufferFile file (buffer);" 로 옮김
buffer.Unpack (P.LastName);
buffer.Unpack (p.FirstName);
```

<aside>
💡 5장

</aside>

<aside>
💡 키(key)

</aside>

![스크린샷 2023-11-01 14.22.24.png](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-11-01_14.22.24.png)

키 : 레코드 필드 값에 기반하여 레코드를 식별

- 유일성(uniqueness) : 하나 이상의 필드의 조합으로 유일하게 레코드를 식별
- 최소성(minimality) : 유일성을 만족시키는 최소 개수의 필드 조합 키 종류

키의 종류

- 주키(primary key) : 응용 프로그램 환경에서주로 사용될 키 (유니크 키 를 만족해야함)
- 보조키(secondary key) : 유니크 키 를 충족할 필요가 없는 보조 키

키의 표준 형식

- 키가 일정한 형식을 가지도록 규칙을 가지게 함

![스크린샷 2023-11-01 14.30.05.png](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-11-01_14.30.05.png)

키를 선택 할 때

- 유일성

- 데이터를 포함하지 말 것
    - 키에 데이터를 포함자지 말 것
- 지속성
    - 주키는 불변해야함
    - ex) 과거에는 주키(학번으로 사용 했을때 입학년도가 2자리로 시작했다. 요즘은 4자리)
    

![스크린샷 2023-11-01 14.35.57.png](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-11-01_14.35.57.png)

<aside>
💡 순차검색

</aside>

검색기능

n개의 레코드의 파일을 순차 검색하기에 필요한 비용은 n에 비례함

- 평균적으로 n/2의 시간
- O(n)

![스크린샷 2023-11-01 14.39.59.png](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-11-01_14.39.59.png)

클러스터당 10개의 레코드를 읽어온다면

시간인 n/10 이 된다

그렇게 해도 빅 오 표기법으로 하면 O(n)

성능이 같다.

![스크린샷 2023-11-01 14.42.03.png](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-11-01_14.42.03.png)

순차 검색의 장점

- 프로그래밍이 용이
- 단순한 파일 구조

순차 검색의 사용처

- 일정한 페턴이 없는곳에서 검색
- 레코드 수가 적은 경우
- 검색을 자주 사용할 필요가 없는 경우

<aside>
💡 직접 접근

</aside>

![스크린샷 2023-11-01 14.45.33.png](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-11-01_14.45.33.png)

- 레코드의 시작 위치로 한번에 탐색하고 읽기 가능
    - 시간 복잡도 : O(1)

```cpp
int IOBuffer::DRead (istream &stream, int recref){   
						//DRead << 해당 주소를 가지는 것을 바로 읽어라
    stream.seekg (recref, ios::beg);
    if (stream.tellg() != recref) return -1;
    return Read (stream);
}

```

직접 주소 방식은 고정 길이 레코드에 적합함

![스크린샷 2023-11-01 14.47.40.png](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-11-01_14.47.40.png)

고정 길이 레코드일 때 사용가능하다.

레코드의 상대 번호

- 128바이트의 고정길이 레코드의 RRN이 546인 경우
    - 바이트 주소 = n(RRN) * r(레코드 크기) = 546 * 128 = 69888

![스크린샷 2023-11-01 14.50.18.png](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-11-01_14.50.18.png)

섹터 크기 : 512바이트

레코드 길이 :  32바이트

고정길이 레코드 내에서 사용 되지 않는 공간과 실제 데이터 사이의 구별문제

- 가변길이 레코드 표현 방법 사용
    - 길이 필드 사용, 필드 수를 고정, 구분자

고정 길이 공간에 가변 길이 레코드를 저장하면

실제 데이터와 주소값을 구별할 수 없게 된다.

그래서 실제 데이터의 길이를 포함하는 필드 정보를 넣어야함

<aside>
💡 헤더 레코드

</aside>

![스크린샷 2023-11-01 15.09.07.png](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-11-01_15.09.07.png)

헤더 레코드

- 파일에 대한 정보를 가지고 있는 레코드?

파일의 정해진 구역에 헤더 레코드에 대한 정보를 넣어둔다.

파일을 실행하는 프로그램이 헤더레코드를 분석하는 방법은 안다면 가능

![스크린샷 2023-11-01 15.29.18.png](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-11-01_15.29.18.png)

![스크린샷 2023-11-01 15.29.57.png](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-11-01_15.29.57.png)

![스크린샷 2023-11-01 15.32.32.png](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-11-01_15.32.32.png)

파일을 여는 방법

read Header를 open 한다.

![스크린샷 2023-11-01 15.36.52.png](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-11-01_15.36.52.png)

template <class RecType> 

- 템플릿 클래스 (자바에서 제네릭 클래스)

int Read(RecType , . . . . , . . . . )

![스크린샷 2023-11-01 15.42.51.png](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-11-01_15.42.51.png)

```cpp
DelimFieldBuffer DelimBuffer('=');  // 가변 길이로 선택한다. 딜리미터는 "=" 이다.
...
RecordFile<Person> PersonFile(DelimBuffer);  // 딜리미터 방식의 레코드고
Person person;//객체 생성                           //펄슨 객체를 사용한다.
PersonFile.Create(“person.dat”, ios::out);//파일을 만든다.
cin >> person;    // person 객체에 입력함
PersonFile.Write(person); //파라미터로 person 만 전달하면ㄷ ㅗ;ㅁ
PersonFile.Append(person);PersonFile.Open(“person.dat”, ios::in);
...
FixedFieldBuffer  FixedBuffer(4, 58);// 고정길이 필드 생성 4개의 필드로 저장됨, 
Books book;  // 객체 생성
RecordFile<Books> BooksFile(FixedBuffer);
BooksFile.Open(“books.dat”, ios::in);
BooksFile.Read(book);
cout << book;
```

![Untitled](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/Untitled.jpeg)

운영체제 / 하드웨어마다 파일일 읽는 법이 다르다

A : 운영체제는 4바이트 씩 읽고

B : 운영체제는 6바이트 씩 읽는다.

호환성 문제가 발생함

![Untitled](11%2001%20(%E1%84%89%E1%85%AE)%209week1%20c72b7d49376a4740941e4e0a6d6c963c/Untitled%201.jpeg)