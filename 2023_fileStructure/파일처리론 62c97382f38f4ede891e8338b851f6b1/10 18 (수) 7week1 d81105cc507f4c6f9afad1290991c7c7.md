# 10.18.(수) 7week1

![스크린샷 2023-10-18 14.05.29.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.05.29.png)

<aside>
💡 필드와 레코드의 구성

</aside>

기본 파일 구조

- 파일의 논리적 기본 단위 : 레코드

바이트의 연속인 파일

- 다음 이름과 주소를 사용 :

![스크린샷 2023-10-18 14.10.33.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.10.33.png)

![스크린샷 2023-10-18 14.09.08.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.09.08.png)

```cpp
#include <fstream.h>
#include <string.h>
#include "readper.cpp"
ostream &operator<<(ostream &stream, Person &p)
{ // insert fields into file
    stream << p.LastName << p.FirstName << p.Address << p.City << p.State << p.ZipCode;
    return stream;
}
int main()
{
    char filename[20];
    Person p;
    cout << "Enter the file name:" << flush;
    cin.getline(filename, 19);  //파일 이름이 문자열에 읽혀짐
    ofstream stream(filename, ios::out);  		//write 전용 파일 스트림이다.
                               	  //ios::out  라이트 온리 모드로 오픈
    if (stream.fail()) // 바로 직전 I/O 가 잘 오픈 했는지 검사 
    {
        cout << "File open failed!" << endl;
        return 0;
    }
    while (1) {
        cin >> p; // 입력하는 오퍼레이터    p는 바로 밑 내용 Person class 
        if (strlen(p.LastName) == 0) // EOF 를 나타넴 
            break;
    stream << p; // p 에 있는 필드 6개를 파일에 넣는다.
    }
    return 1;
}

```

이 프로그램을 실행하면

writestr.cpp 에 아래와 같은 값이 저장됨

![스크린샷 2023-10-18 14.20.18.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.20.18.png)

![스크린샷 2023-10-18 14.22.04.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.22.04.png)

Person 클래스 객체는 61 바이트 공간을 가짐 :

10 + 10 + 15 + 15 + 2 + 9

단점 

- 내부 단편화로 인한 공간 낭비

장점

- 데이터 처리가 단순
- 모든 필드의 길이가 미리 결정되어 있고 변하지 않을 때 적합함

![스크린샷 2023-10-18 14.25.59.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.25.59.png)

방법 2 : 각 필드에 바이트 크기를 포함함

- 필드 처음에 길이를 포함하는필드를 저장하
- 단점 : 길이 필드를 위한 추가 공간이 필요함
- 모든 정보가 길이가 같아도 길이에 데이터를 가지고 있어야함
    - EX) 주민등록 번호

방법3 :  구분자로 필드 사이를 분리

- 필드의 값으로 나타나지 않을 특정 문자를 구문자로 사용

방법 4 : ” 키워드 = 값 “ 표현

- self -describing 구조 :

<aside>
💡 필드 구조를 저장하는 예시

</aside>

![스크린샷 2023-10-18 14.29.40.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.29.40.png)

fixed - length 방식

**각 필드의 길이를 고정**

![스크린샷 2023-10-18 14.29.58.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.29.58.png)

p

length indicator
**필드에 바이트 크기를 포함 하는 방식**

![스크린샷 2023-10-18 14.31.15.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.31.15.png)

모든 문자마다 길이데 대한 정보를 가지고 있음

ex)

- 04,    09123, 10, 02,

**delimiter**

**구분자를 이용한 방식**

![스크린샷 2023-10-18 14.32.35.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.32.35.png)

**키워드 = 값    표현**

![스크린샷 2023-10-18 14.33.49.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.33.49.png)

바로 다음에 있는데이터가 어떠한 필드를 이용한 데이터 인지를 

ex)

- address << 다음 필드에 주소가 있구나
- city  << 다음 필드에 주소가 있구나
- 

![스크린샷 2023-10-18 14.39.44.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.39.44.png)

코드 해석 하기 GPT

```cpp
#include <fstream.h>
#include < string.h>
#include "writeper.cpp"
istream & operator >>  //읽기용 연산자
		(istream &stream, Person &p){ //p
    char delim;
    stream.getline(p.LastName, 30, '|'); // p를 읽어 p.lastname에 넣음,  
																				 // 30자 씩 읽고 30자 안에 버티컬바가 있으면 
																				 // 거기서 끊음 버티컬 바 없으면 그냥 30자만 읽음

	    if (strlen(p.LastName) == 0)       // EOF를 나타넴
        return stream;

    stream.getline(p.FirstName, 30, '|');
    stream.getline(p.Address, 30, '|');
    stream.getline(p.City, 30, '|');
    stream.getline(p.State, 15, ' | ');
    stream.getline(p.ZipCode, 10, ' |');
    return stream;

    ｝
}

main(){
    char filename[20];
    Person р;
    cout «< "Enter the file name:" << flush;
    cin.getline(filename, 19);
    ifstream file(filename, ios::in);
    if (file.fail())
    {
        cout « "File open failed!\n";
        return 0;
    }
    while (1)
    {
        file >> p;  //person 파일을 읽음
        if (strlen(p.LastName) == 0)
            break;
        // write person to file
        cout << p;
    }
}
```

<aside>
💡 레코드 단위로 끊기

</aside>

![스크린샷 2023-10-18 14.46.06.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.46.06.png)

레코드 구조를 구성하는 다양한 방법

1. 고정 길이 레코드
- 레코드의 길이가 미리 결정됨

1. 필드들의 수를 고정
- 레코드는 미리 정의된 개수의 필드들로 구성

1. 길이종보 기준
- 레코드의 첫번째 필드에 레코드의 길이를 저장함

1. 레코드에 대한 주소를 저장
- 별도 파일에 각 레코드에 대한 주소 값을 저장함

1. 레코드 구분자로 줄바꿈 문자나 ‘#’ 등을 사용 가능

![스크린샷 2023-10-18 14.49.54.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.49.54.png)

1번 방법

![스크린샷 2023-10-18 14.50.01.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.50.01.png)

고정 길이 필드의 

고정 길이 레코드 구조

- 이렇게 하면 공간이 딱 맞으나 나중에 값을 추가할 때 범위를 벗어날 수 있음

2번 방법

![스크린샷 2023-10-18 14.50.24.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.50.24.png)

가변 필드의

고정길이 레코드 구조

- 버티컬 바 만큼 끊고 파일을 저장하다 보니 나중에 빈 공간 남음 “unused space”

길이가 남아 남은 공간 활용 가능

3번 방법

![스크린샷 2023-10-18 14.53.11.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.53.11.png)

PPT 오류

![Untitled](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/Untitled.jpeg)

처음 40 만큼 파일을 읽고

거기에 구분자를  두어 다시 읽음

4번 방법

![스크린샷 2023-10-18 14.55.11.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.55.11.png)

5번 방법

![스크린샷 2023-10-18 14.56.37.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.56.37.png)

#을 이용해서

> 필드 끊는 용도
> 

# 레코드 끊는 용도

![스크린샷 2023-10-18 14.57.21.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_14.57.21.png)

가변 길이 레코드 쓰기

```cpp
const int MaxBufferSize = 200;
int WritePerson(ostream &stream, Person &p)
{
    char buffer[MaxBufferSize];

    strcpy(buffer, p.LastName); strcat(buffer, “|”);
    strcat(buffer, p.FirstName); strcat(buffer, “|”);
    strcat(buffer, p.Address);strcat(buffer, “|”);
    strcat(buffer, p.City); strcat(buffer, “|”);
    strcat(buffer, p.State); strcat(buffer, “|”);
    strcat(buffer, p.ZipCode); strcat(buffer, “|”); 

    short length = strlen(buffer);//숏 타임의 렝스 값을 받아서 파일에 기록함
    stream.write(&length, sizeof(length));  //파일에 저장되는 길이 값
    (buffer, length); // 파일에 저장된 내용
}
```

![스크린샷 2023-10-18 15.03.13.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_15.03.13.png)

2-바이트 이진수

- 0 에서 65.535 사이의 길이 표현 가능
- 

2-바이트 아스키 문자

- 0에서 99 까지 길이 표현 가능
- 

4장 레코드 필드 빼곤 중간시험에 안냄

![스크린샷 2023-10-18 15.21.19.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_15.21.19.png)

```cpp
istream &operator >>
		(istream &stream, Person &p)
{ // read fields from stream
    char delim;
    stream.getline(p.LastName, 30, '|');
    if (strlen(p.LastName) == 0)
        return stream;
    stream.getline(p.FirstName, 30, '|');
    stream.getline(p.Address, 30, '|');
    stream.getline(p.City, 30, '|');
    stream.getline(p.State, 15, '|');
    stream.getline(p.ZipCode, 10, '|');
    return stream;
}

int ReadVariablePerson(istream &stream, Person &p)
{
    short length;  
    stream.read((char *)&length, sizeof(length)); 
			// 이 바이트 수 만큼 레코드를 읽으면

    if (stream.fail())
    {
        p.LastName[0] = 0;
        return 0;
    }
    char *buffer = new char[length + 1];
    stream.read(buffer, length);
    buffer[length] = 0;
    istrstream strbuff(buffer);
    strbuff >> p;
    return 1;
}
```

![스크린샷 2023-10-18 15.25.24.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_15.25.24.png)

Read/Write : 레코드 수준의 읽고 쓰기 (버퍼의 내용)

Unpack : 버퍼의 내용을 필드로 가져오는 것

pack : 필드 하나의 데이터를 버퍼에 추가 하는 거

![스크린샷 2023-10-18 15.37.21.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_15.37.21.png)

중요함

1번 : 고정길(fixed-length) 레코드 : 고정길이 필드(fixed-length fields)

2번 : 가변길이(variable-length) 레코드 : 길이기반(length-based) 필드

3번 : 구분자 (delimited) 방식 필드

![스크린샷 2023-10-18 15.40.21.png](10%2018%20(%E1%84%89%E1%85%AE)%207week1%20d81105cc507f4c6f9afad1290991c7c7/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-18_15.40.21.png)

```cpp
class DelimTextBuffer    //딜리미터 방식 필드 구분함
{
public:
    DelimTextBuffer(char Delim = '|', int maxBytes = 1000);   
			//기본 생성자   char Delim = '|' 이걸로 필드를 구분함
    void Clear();

    int Read(istream &);  //리드  레코드 수준으로 읽음
    int Write(ostream &) const;  //라이트   레코드 수준으로 쓰기
    int Pack(const char *, int size = -1); //딜리미터 방식으로 
    int Unpack(char *);                    //딜리미터 방식으로

    void Print(ostream &) const;
    int Init(char delim, int maxBytes = 1000);

private:
    char Delim;
    char DelimStr[2];  
    char *Buffer;
    int BufferSize;
    int MaxBytes;
    int NextByte;
};

//국룰
// 안지켜도 되나 나중에 코드 읽을 때 편해짐
// 대문자로 시작하는 변수면 클래스의 멤버데이터나 멤버 메소드
// 소문자로 시작하면 로컬 변수
```