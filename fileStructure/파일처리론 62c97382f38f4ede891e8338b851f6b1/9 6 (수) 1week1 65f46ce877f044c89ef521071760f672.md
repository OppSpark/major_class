# 9.6.(수) 1week1

파일 처리
하드디스크 장치에 구조를 학습함

중요하게 다룰 것 Index, Tree 구조

# Chapter 1.

![스크린샷 2023-09-06 오후 2.13.39.png](9%206%20(%E1%84%89%E1%85%AE)%201week1%2065f46ce877f044c89ef521071760f672/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-09-06_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.13.39.png)

RAM에 대한 접근 시간 : 120nanoseconds(10^-9)초 

디스크에 대한 접근 시간 : 30milliseconds(10 ^ -3)초

RAM 접근 시간이 20초 라면 디스크 접근 시간은 500만초(58일)

파일구조란?

- 데이터 표현 방법과 데이터 접근 연산을 정의
- 필요한 연산 : 판독(read), 기록(write), 수정(modify), 검색(search)

![스크린샷 2023-09-06 오후 2.29.52.png](9%206%20(%E1%84%89%E1%85%AE)%201week1%2065f46ce877f044c89ef521071760f672/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-09-06_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.29.52.png)

디스크의 설계 목표

- 접근 횟수 최소화
- 이상적으로 1번만 접근 , 불가능하다면 2~3번 접근

파일구조의 역사

1. 테이프 시간복잡도 O(n)
2. tree 구조 기반
    1. AVL 트리 사용
3. B-tree : 
4. Hashing  :

![스크린샷 2023-09-06 오후 2.39.37.png](9%206%20(%E1%84%89%E1%85%AE)%201week1%2065f46ce877f044c89ef521071760f672/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-09-06_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.39.37.png)

# Chapter 2.

기초적인 파일처리 연산

![스크린샷 2023-09-06 오후 2.42.08.png](9%206%20(%E1%84%89%E1%85%AE)%201week1%2065f46ce877f044c89ef521071760f672/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-09-06_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.42.08.png)

<aside>
💻 물리적 파일과 논리적 파일

</aside>

물리적 파일

- 논리적 파일
- ex 자바     File in_f = new File(” ../DATA/input.txt”)
    - //여기서 input.txt는 논리파일      in_f 는 물리적 파일
- 물리적 파일은 / 파일정보, 디스크 정보, 경로명 등등 전부 포함됨,

논리적 파일

- 프로그램 안에 있는 File 을 논리적 파일이라고 함
- ex) 어떤 프로그램을 실행할 때 프로그램을 실행하고 다른 파일을 불러오는 파일을 말 함
- 논리적 파일은 / 필요한 정보만 들어감,

UNIX 에서 단일 프로그램은 20개의 논리적 파일을 사용 가능

0~2 번은 입출력,에러 로 예약됨     나머지 17개를 사용함

![스크린샷 2023-09-06 오후 2.50.38.png](9%206%20(%E1%84%89%E1%85%AE)%201week1%2065f46ce877f044c89ef521071760f672/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-09-06_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.50.38.png)

<aside>
💻 파일 열기

</aside>

open

close

read

write

fd = open(filename, flags [, pmode])

- open →
- flags → 파일을 읽을것인지 쓸것인지 물어보는 것
- [, pmode]) → 권한
- 

fd(int) : 파일 실행(파일 식별자[file descriptor)) 후 오류 발생시 -1 을 리턴

- EX) 실행을 했는데 경로가 잘못되었거나, 파일이 없거나 등등 시 -1 리턴

flgas(int)

O_APPEND   파일의 끝 부분 부터 기록 함

O_CREAT  파일을 생성 하는 것

O_EXCL  파일을 실행할 때 지정된 파일이 있다면 오류를 출력함

O_RDONLY  리드 온리   읽기전용 파일

O_WRONLY  라이트 온리   파일의 첫 부분 부터 기록함 / 파일이 없다면 생성함

O_RDWR   리드 라이트 온리  / RD WR 합친 것 

O_TRUNC  파일 안 데이터를 빈것으로 만드는 것 / 

pmode(int)

-pmode = 0751 =               (0751) 8진수

111(rwx:owner) 101(r-x:group) 001(--x:others)

- 111 → (본인 권한 설정)첫번째 부터 리드, 라이트 실행,
- 101 → (그룹 사용자 권한 설정) 리드,라이트, 실행
- 001 → (다른 사용자 권한 설정) - - -

![스크린샷 2023-09-06 오후 3.05.36.png](9%206%20(%E1%84%89%E1%85%AE)%201week1%2065f46ce877f044c89ef521071760f672/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-09-06_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.05.36.png)

1번

- fd = open(filename, O_RDWR|O_CREAT, 0751);
- 파일을 읽기 쓰기 권한으로 생성한다.

2번

- fd = open(filename, O_RDWR|O_CREAT|O_TRUNC, 0751);
- 파일을 읽기 쓰기 권한으로 생성한다. 만약 기존 공간에 파일 이 있다면 기존 내용을 삭제함

3번 

- fd = open(filename, O_RDWR|O_CREAT|O_EXCL, 0751);
    
    // fail if the file exists
    
    이미 지정된 파일이 있으면 오류를 발생
    

4번

- close(fd);
- 종료

![스크린샷 2023-09-06 오후 3.13.15.png](9%206%20(%E1%84%89%E1%85%AE)%201week1%2065f46ce877f044c89ef521071760f672/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-09-06_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.13.15.png)

```
count = read(src_file, dest_addr, size);	 
	src_file(int) ->  파일 식별자
	dest_addr(char *) ->  읽은 데이터를 저장할 주소값 (배열 이름)
	size(int) ->  성공적으로 읽은 데이터의 바이트 크기
	count(int) ->  읽을 데이터의 바이트 크기
	− nbytes = read(fd, buffer, 256);

− nbytes = read(fd, buffer, 256);
파일의 첫번째 바이트 부터 256byte 만큼 읽고 넘어감
리턴 값은 256
	마지막 값은 256byte 가 아닌 경우가 많으니 값이 256 보다 작으면 끝
```

```
	
 count = write(dest_file, src_addr, size);
		dest_file(int) -> 파일 식별자
	 src_addr(char *) -> 기록할 데이터의 주소값
	 size(int) -> 성공적으로 기록된 데이터의 바이트 크기
	 count(int) -> 기록할 데이터의 바이트 크기	− nbytes = write(fd, buffer, 256);
	파일 첫번째 파일 부터 256만큼 write 
```